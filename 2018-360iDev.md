# 360iDev 2018
* Denver, CO
* Other notes:
	* https://github.com/UberNick/360iDev2018


## Lesons Learned
* Install the Xcode beta the week before the conference, in case you need to update the OS too


## Sessions I Missed
I definitely want to watch the videos from these later:

* Graphing with Custom Collection View Layouts
* Enumerating The Reasons

## Crafting Great Presentations
* Jay Thrash
	* @jaythrash
	* jay@jaythrash.com
	* https://jaythrash.com/talks
* Key Takeaways
	* Consistency
	* Importance of story-telling
	* Practice practice practice

Notes

* Development Process
	* Conceive
	* Visualize
	* Present
* Phase 1: Conceive
	* Everything begins with a message
	* Message begins with a purpose
	* What are the fundamental goals of giving a presentation in the first place?
		* Spreading ideas and motivating others
		* Engage interest, and resonate with them to form a lasting impression
	* Rule of 3 Ls: Listen, Learn, Last
		* Listen: engaging the audience. Quality of the presentation, leveraging the medium (not just reading bullet points from the slides)
		* Learn: relevant, quality content, acceptable risk
		* Last: makes a lasting impression. Resonates, motivates change, spreads beyond the room
	* Focus on reaching your audience
		* Identify with your audience, empathize with their needs, prioritize their needs
	* Amplify through authority and authenticity
		* Don't fall into the trap of believing you need to be an expect before you can talk about a topic
		* Problem: Don't need to solve all the problems, solve one problem
		* Experience: You may have personal experience in the matter
		* Audience: You might be one type of an expert when presenting to your own team, vs presenting at WWDC. Find the audience where you can be the expert in the topic at hand.
	* Developing your message. Four steps:
		1. Topic
			* eg: Struggle -> breakthrough
			* eg: Message of success
		2. Brainstorm
			* Quantity over quality
			* Research: find other people who have had similar or contradicting results, to cover all bases
			* Pick the highlights
			* Divergent vs. convergent thinking: start with one thought and spread from there (divergent), or narrow down to the specific topics/areas that are good enough to include (convergent)
		3. Story
			* Crafting your story
				1. Structure. Beginning, middle, end: three-act structure
				2. Quest. Hero's journey: hero, adventure, crisis, victory, return transformed
				3. Shape. Exposition, rising action, climax, falling action, denouement (note that this follows the hero's journey)
			* Great presentations follow a common structure, up and down:
				* What is: This is how things are
				* What could be: the ideal we could be achieving
				* Alternate back and forth
				* End with the new norm, where the lofty goal you're tring to present is a norm that can be sustained
				* Want to show the struggle and conflict, show that you've been at the "what is" where people in the audience may be, and have come out on top
		4. Structure
* Phase 2: Visualize
	* More than words: **see** what you're saying
	* Color
		* Keep it simple. Use 3, maybe 4 colors, define a pallette
		* Use the same color when highlighting a particular idea throughout, to bring consistency to that topic
		* Maybe use different pallettes for different sections. For example, Jay used different background colors for the three main sections of this talk
		* Don't re-invent the color wheel. Some helpful sites
			* http://www.colourlovers.com
			* http://color.adobe.com
		* Contrast is critical
			* Also keep in mind that the environment you're presenting in might have more limited color range (projector vs. retina monitor)
			* Suggestion: try all color combos in the pallete (blue on black, black on blue, etc) and check them out to see how they each look
	* Typography
		* Again: keep it simple. Find a few that you can use
		* Just like color, assign the fonts a purpose. For example: title, subtitle, body text, flourish (something scripty for flavor), etc
		* Make sure to pick a good monospace for code samples
		* Look for fonts that look good huge: they're going to be big on-screen. Err on the side of larger, more readable text.
	* Layout
		* Unity, flow, contrast
		* Unity affords consistency
		* Flow conveys direction
			* The flow of information on a slide might be obvious to you, but not to your audience. Be sure to give this consideration and make the flow obvious.
			* Use size and perspective: make the primary item larger
			* Animation: incrementally add information in the order appropriate (how to expose this in non-presented format like PDF of slides?)
			* Make it explicit: number them, or draw an arrow
		* Contrast provides importance
			* Contrasting size, shape, color, proximity/position (clustering, separate item)
	* Content guidelines
		* Images
			* Use the space: make images large, or even make them the background and overlay text
			* Keep contrast in mind, if placing text over image
				* Adjustments you can make: desaturate the image, or put a translucent color between the image and text
		* Code
			* Practice if you're doing live-coding
			* Use presenter theme in Xcode
			* Consider using a playground
			* Highlight the key changes, whether coding live or showing it on a slide
		* Motion/animation
			* Less is more
			* Use it as a seasoning
			* Focus attention: draw to a specific thing, but not so much motion to distract from what you're saying
			* Effective use: show a change/improvement, like on a graph
	* Keynote has an outline mode
		* You can paste a markdown outline in there, and it'll create the slides and stuff for you
* Phase 3: Present
	* Confidence through preparation
	* Prior to the event
		* Practice practice practice
		* Record and listen to yourself, then critique
		* Repeat as necessary
	* Presentation day
		* Room recon
			* Arrive early
			* Check connections: need a video adapter? What's the mic setup?
			* Room layout: Is there a podium? What's the layout? How much can I roam? Are there cables on the floor I need to watch out for?
			* Create a test pattern slide to check your slide design
				* Fill the screen
				* Demonstrate the various text-on-background colors you're using, so you can check contrast on the projector
				* Include some circles, so you can check if it's stretching your content
				* Include your custom fonts, in case your slides will be going on a shared presentation machine, which might not have the fonts installed
			* Check position of the screen. From the back row, will content at the bottom of the screen be blocked by other people? You might need to ensure your key points are in the top half.
		* Preflight checklist: make sure you've got everything you need
			* Have a backup copy of your presentation, in the cloud, on a thumb drive, etc, in case your laptop dies
			* Gadgets and extra batteries: clicker, dongles
			* "Clean your room"
				* If you're transitioning from Keynote to Xcode, clean up your desktop, close other apps, etc
				* Mute notifications (alt-click on notification center in menu bar)
				* If you don't need a network connection, just turn off wifi
		* Stand and deliver
			* Try to think of it as a conversation with friends. Keep it relaxed.
			* Develop a warm-up ritual that works for you
			* Find your "mic-ed up voice" and make sure you talk consistently to the mic
			* Relax and pace yourself. Pause after important points to give it a moment to sink in, take a look at the audience and see if they're "getting it." Reiterate, check for questions, etc if needed.
			* Eye contact, not slide contact. Look at the audience, not your own slides
				* Find some anchors, people who seem to be getting it. If you notice they look confused by something, that might be a good read on how the rest of the audience is feeling.
		* It's a wrap, you've done it
			* Be available for questions
			* Take some time to reflect and evaluate your performance
			* Determine message effectiveness
			* Refine and repeat: present again elsewhere, with your adjustments
* Final thoughts
	* Books that are helpful
		* Slide:ology (Nancy Duarte)
		* Resonate (Nancy Duarte)
		* Presenation Zen
		* It's the Way You Say It
	* Finding "anchors" in the audience
		* Not much to it: who's paying attention? Who's making eye contact?
	* Getting feedback
		* Conferences often collect and provide feedback, which is really helpful
	* Presenter notes/display
		* You can increase the font on presenter notes to make them easier to read while presenting
		* The more you have in your notes, the more you'll rely on them. Takes you out of presenting a bit, makes it harder to connect with audience.
* Misc links
	* https://www.deckset.com: Good for code samples, reveal some code at a time

## Building an A/B Testing Framework that Works for Developers
* Jenny Chang Ho
* GrubHub
* @TipTopGS

Notes

* Four ways to think about A/B testing
	1. Testing a hypothesis
	2. Feature flagging
	3. Controlling rollout of new features
	4. Innovating while minimizing risks
* Testing can be messy
	* Dead code: variant no longer used, but code is still in place
	* Increased testing scope
	* It's not for everyone: if you don't have a lot of users, you can't really achieve statistical significance
* Experiment examples
	* Include option to schedule future deliveries
	* Default starting tab when launching the app
* "Fail early, fail often, but always fails forward"
* How to be a good loser
	* Understand what could go wrong, and question assumptions
		* Fully understand the experiment and what is being tested
		* Ask product owners questions
		* Make sure you're clear about potential conflicts with other experiments
	* Evaluate the tools: testing framework setup and customization
		* Some frameworks offer ways to qualify a user for an experiment: eg, new vs. returning customer
	* Should every feature havfe a feature flag?
	* Create debug settings (for QA)
	* Automate tests
		* Experiments can take a long time, and regression testing control and experiment over time can become a big effort
	* Unit test default feature flag values (control)
	* Write code that's easier to make permanent, or delete, depending on experiment outcome
		* Composition over inheritance
		* Use multiple nibs, for different design variations
	* Setup a cleanup process
	* Use the results from other platform
		* Test something on Android, and make use of that data
* Take aways
	* Check the assumptions
	* Setup a cleanup process
	* Decide between feature flag and kill switch (not a feature flag as we use them)
	* Automate tests as much as possible

## The Complicated Life of a Backgrounded iOS App
* Agnes Vasarhelyi
* @vasarhelyia
* https://blog.alltheflow.com

Notes

* Handling background transfers
	* URLSession API: need to move away from completion handlers to delegate-based APIs
		* Example: start a background task, then background the app. It's suspended. It's not running code: need a delegate method to call when it's launched in the background to handle that response.
	* Good to know: users can turn off background transfer capability in Settings
	* Tasks have an isDiscretionary property. Set this for stuff that isn't time-sensitive, and the OS will execute when the conditions are right (phone charged, etc)
		* Tasks started in the background default to true on this
* Silent (content) push notifications
	* content-available flag set
	* App is resumed in background, with limited time: around 30 seconds
	* No user permission required
	* Similar to background fetch, but triggered remotely instead of scheduled locally
	* Surprises
		* Users can switch it off, by disabling background refresh
			* Lesson: don't implement critical functionality here
		* Rate limited by APNS
		* No more than 2-3 per hour
		* Won't be received when the app was terminated
* Authentication
	* No client trust validation in background session. Bug report open for 4 years.
	* Server trust validation options
		1. Cert pinning: simple, secure
			* No self-signed certs valid in the background, needs to use system-trusted CA (ATS restriction: get around it by disabling ATS)
			* Rolling certs: public key has to be static, so you need to maintain backup keys in the app
			* Longer-living certs cost $$$
		2. Authentication challenge handlers
			* Easier to implement
			* Too many resumes to the app in the background (?)
		3. Custom authentication scheme (recommended approach)
			* Ask for token in the foreground session and authenticate that request, somehow
			* Use that token in the background
* Resume rate limiter
	* nsurlsessiond has a delay value
		* Doubles with each resume
		* Resets to 0 when user activates the app or delay elapses without new task
		* Applies to your app as a whole, not per session
		* Custom authentication implementation doubles the resumes, which considerably impacts this delay time
	* How to make the rate limiter happy
		* Batch transfers
		* Authentication without additional resumes
	* Surprises
		* Free pass for Xcode builds: resume rate limiter ignores debug builds, and doesn't default isDiscretionary to true
		* Call registerForRemoteNotifications on every launch
* Testing
	* Hard to test
* Debugging: make use of Console.app
	* Look at nsurlsessiond logs for networking
	* Look at dasd logs for scheduling
	* Search for your bundle ID
	* Put the pieces together
		* Watch for pid values to string together
* Tips
	* Only use background transfer for time-insensitive work
	* Design networking around the resume rate limiter
	* Same for authentication
	* Master usage of Console.app

## A Concrete Definition of How to Go From Juion Developer to Mid-Level
* Jen Kelley
* @thehulkstory

Notes

* 1. Things that everyone says you should do
	* Break things into smaller pieces
	* Tests
* 2. General Computer Things
	* Source control
	* Networking
	* Immutability vs mutability
* 3. iOS-specific things
	* Know your platform and common pitfalls
		* Tools, like Xcode
		* View lifecycle, responder chain
		* Sizing, constraints
		* Common design elements, like table views
	* Don't rebuild the wheel
		* Third party dependencies
* 4. Overall knowledge
	* "Classic" computer science books
		* Code by Petzold
		* Working Effectively with Legacy Code by Feathers
		* Design Patterns by Gang of Four
	* Go to meetups/conferences
		* Learn how much you actually know
		* Communicate
	* Ask questions
		* Everybody starts out knowing nothing
		* More-experienced people tend to use slang/acronymsâ€”don't hesitate to ask
		* If someone can't explain something they seem to know about, they probably don't actually understand it
* The big difference between junior and mid-level devs: the ability to answer "why" in addition to "how"
* Questions
	* Anything you didn't know for a while and wish you knew sooner?
		* Decoupling code and what it really means. Provide code examples
		* Same for mutable vs. immutable
	* Impostor syndrome among folks without CS degrees
		* Don't need a degree. You can figure out what you need to know from books and stuff.
