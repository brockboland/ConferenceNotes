# 360iDev 2016
Denver, CO

## [Debugging And Xcode – tips and advice](http://360idev.com/sessions/debugging-xcode-tips-advice/)
Kendall Gelner: [@kendalldevdiary](https://twitter.com/kendalldevdiary)

* Visual debugger buttons below view:
	* Show Clipped Views
	* Show Constraints
* Flex
	* Toolbar to view details about views

## [Teaching an iPhone to See: Adventures in Computer Vision](http://360idev.com/sessions/200-teaching-iphone-see-adventures-computer-vision/)
* Michael Schneider
* Hivebrain Software
* [Sample cascade classifier code](https://github.com/hivebrain/cascadeclassifierdemo)

Notes:

* Problem: recognize indicators in a Counter Strike radar HUD
* [TensorFlow](https://www.tensorflow.org/)
* [OpenCV](http://opencv.org/)
* Other choices
	* Convolutional neural network: deep learning
	* Template matching: match a known image, not good with variance
	* Contour matching: matching curves? edge detection
	* Cascade classifier: facial recognition. Been around for a long time, runs fast
		* Starts with a rough and quick test
		* If the image passes, cascades on to the next, more-specific test
		* An algorithm may have 30-50 of these stages
		* Only detects a face if all stages pass
		* Example: does the image have an eye? If yes: does it have a nose? If yes: does it have a mouth? etc
* The gist of how it works:
	* Import OpenCV
	* Use .mm file extension for Objective-C++
	* Load classifier
	* Start a video camera from CvVideoCamera, giving it an image view to display in
	* Give it a delegate, for camera permissions
	* `processImage:` delegate method called for each frame of the video
	* `filter:` method: boost the red to make it easier to identify red dots in the image
* Caveat: only works on grayscale images
* Edge detection is real easy
* Ultimately took about 20k good and 20k bad images to reliably detect
* Lessons learned
	* Smaller images (32x32) train faster

## [The Selfie Developer](http://360idev.com/sessions/100-selfie-developer/)
Steve Scott

## [Compilers aren’t magic, so let’s build one in Swift](http://360idev.com/sessions/300-compilers-arent-magic-lets-build-one-swift/)
* Ben DiFrancesco
	* [GitHub](https://github.com/apbendi)
	* [Twitter](http://twitter.com/bendifrancesco)
* How it works:
	* Define a source 
	* Choose a target language
	* Read stream of source characters
	* Break characters into language components
	* Process instructions in source language
	* Generate instructions in target language
	* Write and finalize source of target language
* Define a source
	* Bitsy: http://github.com/apbendi/bitsyspec
* Define a target language
	* For our purposes: Swift is the target language
* Read stream of source characters and break into language components
	* Tokenization
	* Tokens need two pieces of info
		* Kind of language element it references
		* Original characters from the source
	* Token types:
		* One type, arbitrary value: like an integer
		* Multiple types, specific values: such as keywords like BEGIN or END
	* Tokenizer: walks over stream of characters, returns a stream of tokens
* Process instructions in source language: parsing
	* Succeed if the program is valid, fail if invalid
	* Grammar: definition of set of valid programs
		* For simplest Bitsy program: `BEGIN ws {ws} END`
		* Just a BEGIN, then some whitespace, then an END
	* More complete grammar definition:
		* `Program = BEGIN <block> END`
		* `<block> = { <loop> | <break> }`
		* `<loop = LOOP <block> END`
		* `<break> = BREAK`
* Generate instructions in the target language
	* Code generation: produce code in the target language that has the same effects as those expressed in the source language
		* For example, in the parsing for a loop: `print("while true {")`, then parse the block of the loop, then `print("}")`
	* More complex parsing: less literal, more mechanistic. Use token values in code generation.


## [Cloud Powered iOS Apps with Azure](http://360idev.com/sessions/200-cloud-powered-ios-apps-azure/)
Chris Risner

* Why the cloud?
	* Speed, scale, economics
* Azure app service
	* Web apps
	* Mobile apps
		* DB storage
		* User authentication
		* Logic
		* Push notifications
		* Backend jobs

## Embracing the New Hotness
https://speakerdeck.com/designatednerd/embracing-the-new-hotness-gently-360idev-denver-august-2016

## [Swift + Metal](http://360idev.com/sessions/300-swift-metal-future-scientific-programming/)
Basel Farag

## Practical Swift Generics
https://github.com/jonfriskics/360iDev-2016-PracticalSwiftGenerics

## Automate Your Workflow
https://speakerdeck.com/mediabounds/automating-your-workflow

## [Effective Strategies for Selling Out](http://360idev.com/sessions/effective-strategies-selling/)
[Josh Michaels](http://www.joshjet.net/)

* "Pop apps killed the indie stars"
* "Pop": a work that appeals to a wide audience
* Pop and indie aren't mutually exclusive
* "Niche": work that appeals to a limited audience
* Consider things that push your audience from pop to niche:
	* 60% of people wear glasses: can't use VR headsets
	* 40% of people speak English: everyone else can't use your English-only app
	* 75-90% of people just won't pay for apps
* Things that will reduce your target market
	* Require login/registration
	* Require specific OS version
	* Require specific hardware features
	* Require accessory (like Watch)
	* Require specific language
	* Require up-front payment
* Gotta be free if you want mass appeal
* Appeal to as wide an audience as possible

## [Can You Test It](http://360idev.com/sessions/100-can-test/)
* Derek Rozycki and Kirk Chambers, Possible Mobile
* Automation: not the focus of this talk. Discussing QA strategies.
* State diagram: similar to user flow diagram
	* Can be the basis for a test plan
	* Has nothing to do with development: can develop a QA testing plan from this even before development begins
* Now you've got a happy path
* Deconstructions: state deconstruction, transition deconstruction
* Negative testing: check unexpected input, invalid data from the server, etc
* Repeat tests: users don't launch the app, go to the video section, and tab a button once: they use the app repeatedly
* Don't just test happy path: users will always find a way off the road
* Always do upgrade tests
	* Make sure there are no database/data issues
	* Ensure no debug options are left in place
	* Make sure data, settings, and authentication are retained
* Test different flows into your app
	* App icon tap: where does the user land? Is the network available?
	* Notification tap
	* came back from multitasking chooser
	* Deeplink: does it matter where the user came from? What happens to the current state of the app?
* Hardware states: different device sizes and orientations, with each OS you support
	* Memory limits
* Permissions, or lack thereof
	* Denied by default, granted at runtime
	* Can be turned off at any point
	* Parental controls allow disabling hardware features: for example, the camera can be disabled entirely. Be careful of assumptions about what hardware can do.
* Your app doesn't live in a vacuum
	* For example, in early days, Pokemon Go only worked around midnight because servers were overloaded during daylight hours
* State transitions
	* Does the app go from state 1 to state 2 seamlessly?
	* What if the app is killed and the API goes from state 1 to state 3 before the app is relaunched? Can it cleanly proceed to state 3?
* Accountability: changes need to be documented. QA can't test requirement changes that happen in a phone call and don't get written down.
* 